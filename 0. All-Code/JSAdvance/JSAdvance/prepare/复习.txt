
1, a.b
作用域链： 用来查找变量的，找不到报错
原型链：用来找对象属性，找不到undefined
window.a undefined
a 会报错 

2，作用域：代码书写确定，不会变化，n+1多少函数+ 全局
执行上下文： n+1 调用函数的次数+全局； 动态产生，
调用产生，调用完死掉

3，闭包
* 内部的函数引用外部函数的变量
面试：
* 函数嵌套，里边也是函数，找内部的函数引用外部函数的变量
* 产生闭包的数量：外部函数被调用的次数，调用一次产生一个闭包
- 延长了变量的生命周期
- 闭包内部函数被创建时 产生的
- 闭包是包含被引用变量（函数）的对象
- 闭包是嵌套的内部函数
- 使用chorme 调试查看

- 将函数作为另一个函数的返回值，向外暴露
- 将函数作为实参传递给另一个函数调用

- 闭包的生命周期 ： 
- 内部函数定义时产生，内部函数成为垃圾对象，没有变量引用它了，=null
- 应用：自定义JS模块=一个JS文件，将数据和功能封装在一个函数内部，只向外暴露一个包含N个方法的对象或者函数

- 缺点：不需的变量一直逊在 ，内存溢出， --》不断地创建数组，可以指定大小，一下可以让他特别大； 内存泄漏--》占用内存过多没有及时释放
意外地全局变量，没有辑视清理计时器或者回调函数，闭包
- 解决：及时清理 = null, 让内部函数成为垃圾对象
 

对象地创建
- object构造函数 var obj = { name: "luojin"..}
- 对象字面量 function Person(name,age){this.name=name} new Person(...)
- 构造函数模式
- 构造函数+原型
- 继承模式：子类型地原型指向父类型地实例
 父类型地构造函数.call (this, XxX) 借用构造函数得到属性
- 组合模式：指定原型 

new 一个对象背后？
- 创一个空对象=this
- 给对象设置__proto__, 值为构造函数对象地prototype属性值 
 this.__proto__ = Fn.prototype 
- 执行构造函数体（给对象添加属性/方法）
